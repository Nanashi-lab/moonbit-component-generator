use crate::MoonBitComponent;
use crate::Utf8Path;
use anyhow::anyhow;
use heck::ToSnakeCase;
use indoc::indoc;
use log::debug;
use serde_json::json;
use std::fmt::Write;
use wit_bindgen_core::uwriteln;
use wit_component::WitPrinter;
use wit_parser::{PackageName, Resolve, Stability, Type, WorldItem, WorldKey};

/// Generates a WASM component implementing the given WIT package using either environment variables or
/// the WASI Config API.
///
/// The WIT package is expected to contain a single world exporting a single interface. This interface
/// should contain functions returning configuration values.
///
/// Currently only string functions are supported, but more types (including complex ones) can be added in the future.
pub fn generate_typed_config_component(
    wit_package: &str,
    target: &Utf8Path,
    mode: TypedConfigMode,
) -> anyhow::Result<()> {
    let processed_package = process_wit_package(wit_package, mode)?;
    debug!("Processed WIT package: {}", processed_package.wit_source);

    let mut component = MoonBitComponent::empty_from_wit(
        processed_package.wit_source,
        Some(&processed_package.world_name),
    )?;

    component.define_bindgen_packages()?;

    match mode {
        TypedConfigMode::EnvVars => {
            let moonbit_root_package = component.moonbit_root_package()?;
            let imported_env_path =
                format!("{moonbit_root_package}/interface/wasi/cli/environment");
            component.write_interface_package_json(
                &processed_package.package_name,
                &processed_package.interface_name,
                json!({
                    "import": [{
                        "path": imported_env_path,
                        "alias": "environment",
                    }]
                }),
            )?;

            let pkg_namespace = processed_package.package_name.namespace.to_snake_case();
            let pkg_name = processed_package.package_name.name.to_snake_case();
            let interface_name = processed_package.interface_name.to_snake_case();
            component.add_dependency(
                &format!(
                    "{moonbit_root_package}/gen/interface/{pkg_namespace}/{pkg_name}/{interface_name}",
                ),
                &Utf8Path::new("target").join("wasm").join("release").join("build").join("interface").join("wasi").join("cli").join("environment").join("environment.mi"),
                "environment",
            )?;
        }
        TypedConfigMode::WasiConfig => {
            let moonbit_root_package = component.moonbit_root_package()?;
            let imported_config_store_path =
                format!("{moonbit_root_package}/interface/wasi/config/store");
            component.write_interface_package_json(
                &processed_package.package_name,
                &processed_package.interface_name,
                json!({
                    "import": [{
                        "path": imported_config_store_path,
                        "alias": "configStore",
                    }]
                }),
            )?;

            let pkg_namespace = processed_package.package_name.namespace.to_snake_case();
            let pkg_name = processed_package.package_name.name.to_snake_case();
            let interface_name = processed_package.interface_name.to_snake_case();
            component.add_dependency(
                &format!(
                    "{moonbit_root_package}/gen/interface/{pkg_namespace}/{pkg_name}/{interface_name}",
                ),
                &Utf8Path::new("target").join("wasm").join("release").join("build").join("interface").join("wasi").join("config").join("store").join("store.mi"),
                "configStore",
            )?;
        }
    }

    let mut stub_mbt = String::new();
    uwriteln!(stub_mbt, "// Generated by `moonbit-component-generator`");
    uwriteln!(stub_mbt, "");
    if mode == TypedConfigMode::EnvVars {
        uwriteln!(
            stub_mbt,
            indoc! {
                r#"
                struct CachedEnv {{
                      mut env: Map[String, String]?
                }}

                fn CachedEnv::new() -> CachedEnv {{
                      {{
                            env: None
                      }}
                }}

                fn get_env(self: CachedEnv) -> Map[String, String] {{
                      match self.env {{
                            Some(cached) => cached
                            None => {{
                                  let env_array = @environment.get_environment()
                                  let map = Map::new()
                                  for pair in env_array {{
                                        map[pair.0] = pair.1
                                  }}
                                  self.env = Some(map)
                                  map
                            }}
                      }}
                }}

                fn get(self: CachedEnv, key: String) -> String {{
                      self.get_env().get(key).unwrap()
                }}

                let cached_env: CachedEnv = CachedEnv::new();
                "#,
            }
        );
        uwriteln!(stub_mbt, "");
    }
    for key in processed_package.keys {
        let function_name = key.to_snake_case();
        let env_name = format!("CFG_{}", key.to_uppercase());
        uwriteln!(stub_mbt, "pub fn {function_name}() -> String {{");
        match mode {
            TypedConfigMode::EnvVars => {
                uwriteln!(stub_mbt, "    cached_env.get(\"{env_name}\")");
            }
            TypedConfigMode::WasiConfig => {
                uwriteln!(
                    stub_mbt,
                    "    @configStore.get(\"{env_name}\").unwrap().unwrap()"
                );
            }
        }
        uwriteln!(stub_mbt, "}}");
    }

    component.write_interface_stub(
        &processed_package.package_name,
        &processed_package.interface_name,
        &stub_mbt,
    )?;

    component.build(None, target)?;

    Ok(())
}

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum TypedConfigMode {
    EnvVars,
    WasiConfig,
}

#[derive(Debug)]
struct ProcessedWitPackage {
    wit_source: String,
    package_name: PackageName,
    interface_name: String,
    keys: Vec<String>,
    world_name: String,
}

static WASI_CLI_WIT: &str = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/wit/wasi-cli.wit"));
static WASI_IO_WIT: &str = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/wit/wasi-io.wit"));
static WASI_CONFIG_WIT: &str =
    include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/wit/wasi-config.wit"));

fn process_wit_package(source: &str, mode: TypedConfigMode) -> anyhow::Result<ProcessedWitPackage> {
    let mut resolve = Resolve::new();
    let package_id = resolve.push_str("config.wit", source)?;
    let io_package_id = resolve.push_str("io.wit", WASI_IO_WIT)?;
    let cli_package_id = resolve.push_str("cli.wit", WASI_CLI_WIT)?;
    let config_package_id = resolve.push_str("config.wit", WASI_CONFIG_WIT)?;

    let package = resolve
        .packages
        .get(package_id)
        .ok_or_else(|| anyhow::anyhow!("Failed to get package"))?;

    if package.interfaces.len() != 1 {
        return Err(anyhow::anyhow!(
            "Expected exactly one interface in the WIT package"
        ));
    }

    let interface_id = package.interfaces.values().next().unwrap();
    let interface = resolve
        .interfaces
        .get(*interface_id)
        .ok_or_else(|| anyhow::anyhow!("Failed to get interface"))?;

    if package.worlds.len() != 1 {
        return Err(anyhow::anyhow!(
            "Expected exactly one world in the WIT package"
        ));
    }
    let world_id = package.worlds.values().next().unwrap();
    let world = resolve
        .worlds
        .get_mut(*world_id)
        .ok_or_else(|| anyhow::anyhow!("Failed to get world"))?;

    match mode {
        TypedConfigMode::EnvVars => {
            let cli_package = resolve
                .packages
                .get(cli_package_id)
                .ok_or_else(|| anyhow!("Failed to get wasi:cli package"))?;
            let environment_interface_id =
                cli_package.interfaces.get("environment").ok_or_else(|| {
                    anyhow!("Could not find the environment interface in wasi:cli package")
                })?;

            world.imports.insert(
                WorldKey::Interface(*environment_interface_id),
                WorldItem::Interface {
                    id: *environment_interface_id,
                    stability: Stability::Unknown,
                },
            );
        }
        TypedConfigMode::WasiConfig => {
            let config_package = resolve
                .packages
                .get(config_package_id)
                .ok_or_else(|| anyhow!("Failed to get wasi:config package"))?;
            let store_interface_id = config_package.interfaces.get("store").ok_or_else(|| {
                anyhow!("Could not find the store interface in wasi:config package")
            })?;

            world.imports.insert(
                WorldKey::Interface(*store_interface_id),
                WorldItem::Interface {
                    id: *store_interface_id,
                    stability: Stability::Unknown,
                },
            );
        }
    }

    let mut keys = Vec::new();
    for (name, function) in &interface.functions {
        if function.kind != wit_parser::FunctionKind::Freestanding {
            return Err(anyhow::anyhow!(
                "Expected all functions in the interface to be freestanding"
            ));
        }
        if function.result != Some(Type::String) {
            return Err(anyhow::anyhow!(
                "Expected all functions in the interface to return a string"
            ));
        }
        keys.push(name.clone());
    }

    let world_name = world.name.clone();

    let package_id = interface
        .package
        .ok_or_else(|| anyhow::anyhow!("The exported interface does not have an owner package"))?;
    let package_name = resolve
        .packages
        .get(package_id)
        .ok_or_else(|| anyhow::anyhow!("Failed to get package"))?
        .name
        .clone();

    let mut wit_printer = WitPrinter::default();
    wit_printer.print(
        &resolve,
        package_id,
        &match mode {
            TypedConfigMode::EnvVars => vec![io_package_id, cli_package_id],
            TypedConfigMode::WasiConfig => vec![config_package_id],
        },
    )?;
    let updated_source = wit_printer.output.to_string();

    Ok(ProcessedWitPackage {
        wit_source: updated_source,
        package_name,
        interface_name: interface
            .name
            .clone()
            .ok_or_else(|| anyhow::anyhow!("Interface name is missing"))?,
        keys,
        world_name,
    })
}

#[cfg(test)]
use crate::Trace;
#[cfg(test)]
test_r::inherit_test_dep!(Trace);

#[cfg(test)]
mod tests {
    use crate::Trace;
    use crate::typed_config::TypedConfigMode;
    use camino::Utf8Path;
    use indoc::indoc;
    use test_r::{inherit_test_dep, test};

    inherit_test_dep!(Trace);

    #[test]
    fn generate_typed_config_component_env(_trace: &Trace) -> anyhow::Result<()> {
        let target = Utf8Path::new("target/test-output/generate_typed_config_component_env.wasm");
        let wit = indoc! {
            r#"
                package example:typed-config;

                interface config {
                    username: func() -> string;
                    password: func() -> string;
                    server: func() -> string;
                }

                world example-config {
                    export config;
                }
            "#
        };

        super::generate_typed_config_component(wit, target, TypedConfigMode::EnvVars)?;

        // Testing with external wasmtime-cli
        let output = std::process::Command::new("wasmtime")
            .arg("--invoke")
            .arg("password()")
            .arg("--env")
            .arg("CFG_PASSWORD=secret")
            .arg(target)
            .output()?;

        assert_eq!(output.stdout.trim_ascii_end(), r#""secret""#.as_bytes());

        Ok(())
    }

    #[test]
    fn generate_typed_config_component_config(_trace: &Trace) -> anyhow::Result<()> {
        let target = Utf8Path::new("target/test-output/generate_typed_config_component_conf.wasm");
        let wit = indoc! {
            r#"
                package example:typed-config;

                interface config {
                    username: func() -> string;
                    password: func() -> string;
                    server: func() -> string;
                }

                world example-config {
                    export config;
                }
            "#
        };

        super::generate_typed_config_component(wit, target, TypedConfigMode::WasiConfig)?;

        // Testing with external wasmtime-cli
        let output = std::process::Command::new("wasmtime")
            .arg("--invoke")
            .arg("password()")
            .arg("--wasi")
            .arg("config=y")
            .arg("--wasi")
            .arg("config-var=CFG_PASSWORD=secret")
            .arg(target)
            .output()?;

        assert_eq!(output.stdout.trim_ascii_end(), r#""secret""#.as_bytes());

        Ok(())
    }
}
